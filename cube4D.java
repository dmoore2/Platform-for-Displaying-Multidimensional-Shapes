/*
 * Dear Mehran,
 * 
 * Here's a new screen saver to cheer you up on a rainy day.
 * 
 * Truly,
 * 
 * Dylan
 * 
 * ------------------------------------------------------------------------------------
 * GRAPHICS PROGRAM ENTRY: A Platform for Displaying Multidimensional Shapes
 * 
 * INSPIRATION: I am currently taking Math 51 and this graphics contest seemed an excellent opportunity to combine
 * what I was learning in CS106A with linear algebra. At first my goal was create a rotating cube using a class "Line" consisting of
 * a GLine, two objects of class "Point" and an update() function. I accomplished this goal before break but became possessed with the
 * project and have since spent far too much time thinking how to refine and expand it.
 * 
 * 
 * FUNCTIONALITY: The display can be changed using various JComboBoxes and JCheckBoxes to show different aspects of the given shape. 
 * The JSlider for rotation is configured using a Math.pow function so that the user can easily adjust for more complicated shapes, 
 * which tend to rotate far faster, without compromising the rotation speed of the less complex shapes. The bounce function uses Math.sin.
 * Changing the rotation speed generates a new set of rotation matrices but the coordinates for the shape itself are only regenerated by 
 * choosing an index from the box located on the NORTH region. Color, Lines/Circles and Scale are all changed during rotation. The rotation loop
 * never stops, if the user sets the rotation speed to zero then the shapes' coordinates are multiplied by the identity matrix.  
 * 
 * 
 * HOW IT WORKS: The core idea behind this program is that the generation of the shapes' coordinates and the display platform and display functionalities
 * are separate. This works as follows: when the user calls for a new shape an instance of the class "FileGenerator" is created and 
 * the coordinates are programmatically entered into a text file. Then, the class "CubeVectors" reads in this file and creates "points"
 * (double[] point, such that, point.length = dimensionOfGivenShape) This is critical because it means that the program can be easily expanded to
 * Accommodate shapes of any type in any dimension.
 * 
 * GENERATING THE FILE: This was the first challenge that I confronted. First I wanted to create shapes that were the equivalent of a cube in any
 * dimension. I looked for a pattern in the coordinates of cubes and squares and extrapolated on that to find a method that would give me the 
 * coordinates of equivalent type shapes in higher dimensions. The basic idea of this method is that from each vertex (the only points that are important
 * here) on a square or cube you can only move one unit along one axis. After a long time I figured that you could create a method which calls itself,
 * (which seems like a worrysome thing to do somehow) and fills an arrayList with the appropriate double[]'s. By looking at the coordinates of 
 * an icosahedron, which is composed of rectangles which have side lengths of 1 and the golden ratio, I found that the vertices are all the changes 
 * of signs of the permutations of the values (1, golden ratio, 0). I am working to expand this program to make the 16-cell and a bucky ball.
 * 
 * READING THE FILE/ DISPLAY: The hardest/ most interesting part of the display is the rotation functionality. My idea for displaying a 
 * higher dimensional shape in 2D is to have the coordinates which are not explicitly displayed affect the x and y coordinates of the lines.
 * Generating the matrices for transformation for any dimension was by far the most difficult part of this project because shapes in higher dimensions
 * have many axis of rotation and I wanted to rotate along all of these at once. I approached this problem by drawing out matrices and looking for patterns.
 * I noticed an expansion of results that looked like a factorial appearing (which I had seen in the generation of coordinates problem earlier) 
 * and thus decided to take a similar approach to the problem by generating what I called "matrix seeds" which denoted the axises that would be rotated across and 
 * then systematically filling the spaces in the matrix (double[][]) that were not 1 or 0 with the appropriate trig value. Again I could see no way 
 * around having the "matrix seeds" function call itself but that seems to work.
 * 
 * The circles, which were originally designed to mimic molecules floating in a 3 dimensional space, work much like the lines except they only have
 * one "point" and scale according to the z value of that point.
 * 
 * After learning about Threads I started working on a version of this that would leave a disappearing trail of circles as it rotates.
 * 
 * I hope you enjoy this program, it has been an incredible journey in the making.
 * 
 * Cheers,
 * 
 * Dylan Moore
 * 
 *  
 * 
 */
import acm.graphics.*;
import acm.program.*;
import acm.util.*;
 
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Arrays;
 
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
 
//creates cube at the given coords
public class Cube4D extends Program implements GraphicsContestConstants, ChangeListener{
    /*create lines between the given points*/
    private CubeVectors canvas;
    private Boolean rotating;
     
    public void init() {
        canvas = new CubeVectors(0);
        canvas.addMouseListener(this);
        canvas.setBackground(Color.black);
        canvas.setConstants(400, 400, scalarValue);
        add(canvas);
        FileGenerator fileGen = new FileGenerator(theDimension, "icosahedron", filename); //icosahedron or //square
        canvas.initializeVectors(filename);
        //adds buttons to top
        shapeList = new JComboBox(ARRAY_OF_SHAPES);
        shapeList.setSelectedIndex(6);
        shapeList.addActionListener(this);
        add(shapeList, NORTH);
         
         
        //adds buttons to bottom
        colorList = new JComboBox(COLORS_NAME_ARRAY);
        colorList.setSelectedIndex(0);
        colorList.addActionListener(this);
        linesBox = new JCheckBox("Lines", true);
        linesBox.addActionListener(this);
        circlesBox = new JCheckBox("Circles", false);
        circlesBox.addActionListener(this);
        bounceBox = new JCheckBox("Bounce", false);
        bounceBox.addActionListener(this);
        rotationSpeed = new JSlider(JSlider.HORIZONTAL, 0, 30, INITIAL_ROTATION_SPEED);
        rotationSpeed.addChangeListener(this);
        zoom = new JSlider(JSlider.HORIZONTAL, 0, 500, INITIAL_ZOOM);
        zoom.addChangeListener(this);
        //rotationSpeed.setMajorTickSpacing(10);
        //rotationSpeed.setMinorTickSpacing(100);
        add(linesBox, SOUTH);
        add(circlesBox, SOUTH);
        rotationSpeed.setPaintTicks(true);
        add(new JLabel("Color:"), SOUTH);
        add(colorList, SOUTH);
        add(new JLabel("  Rotation Speed:"), SOUTH);
        add(rotationSpeed, SOUTH);
        add(new JLabel("Scale: "), SOUTH);
        add(zoom, SOUTH);
        add(bounceBox, SOUTH);
    }
     
    public void run() {
        rotating = true;
        rotationSpeedValue = INITIAL_ROTATION_SPEED*SPEED_SCALAR;
        scalarValue = INITIAL_ZOOM;
        generatematrices(theDimension, rotationSpeedValue);
        combineMatrices(1, matrices.get(0));
        double num = 1;
        while (true){
            if (rotating == true) {
                canvas.setScale(((Math.sin(num))+1.4) * 0.5*scalarValue);
                if(bounce == true) num += 0.05;
                rotate(totalRotationMatrix);
                /*for (int i =0; i < matrices.size(); i++) { //rotates on each individual axis separately
                    rotate(matrices.get(i));
                }
                */
            }
            pause(40);
        }
    }
     
    // button events
    public void actionPerformed(ActionEvent e) {
        Object source = e.getSource();
        if (source == shapeList) {
            String shapeName = "square";
            theDimension = shapeList.getSelectedIndex() + 2;
            if(shapeList.getSelectedIndex() == 6) {
                theDimension = 3;
                shapeName = "icosahedron";
            }
            rotating = false;
            canvas.refresh();
            FileGenerator fileGen = new FileGenerator(theDimension, shapeName, filename); //icosahedron or //square
            canvas.setConstants(getWidth()/2, getHeight()/2, scalarValue);
            canvas.initializeVectors(filename);
            generatematrices(theDimension, rotationSpeedValue);
            combineMatrices(1, matrices.get(0));
            rotating = true;
        } else if (source == bounceBox) {
            if (bounceBox.isSelected()) {
                bounce = true;
            } else if (!bounceBox.isSelected()) {
                bounce = false;
            }
        } else if (source == colorList) {
            canvas.setColor(colorList.getSelectedIndex());
        } else if (source == linesBox) {
            if (linesBox.isSelected()) {
                canvas.setLinesVisible(true);
            } else if (!linesBox.isSelected()) {
                canvas.setLinesVisible(false);
            }
        } else if (source == circlesBox) {
            if (circlesBox.isSelected()) {
                canvas.setCirclesVisible(true);
            } else if (!circlesBox.isSelected()) {
                canvas.setCirclesVisible(false);
            }
        }
    }
     
     
    private void rotate(double[][] matrix) {
        for (int i = 0; i < canvas.getAllLines().size(); i++) {
            canvas.getAllLines().get(i).update(matrix);
        }
        for (int i = 0; i < canvas.getAllCircles().size(); i++) {
            canvas.getAllCircles().get(i).update(matrix);
        }       
    }
     
     
    private void generatematrices(int dimension, double angle) {
        matrices.clear();
        matrixSeeds.clear();
        totalRotationMatrix = null;
        if (dimension == 2) {
            matrices.add(new double[][] {{Math.cos(angle), -Math.sin(angle)},{Math.sin(angle),Math.cos(angle)}});
        } else if (dimension > 2) {
            createMatrixSeeds(createArray(dimension, 0));
            creatematricesFromSeeds(dimension, angle);
        }
    }
     
     
    //creates an array of the given dimension with all entries being the given value
    public double[] createArray(int dimension, int value) {
        double[] array = new double[dimension];
        for (int i = 0; i < dimension; i++) {
            array[i] = value;
        }
        return array;
    }
     
     
    //performs matrix multiplication
    private double[][] multiplyMatrices(double[][] matrix1, double[][] matrix2) {
        double[][] endMatrix = new double[matrix1.length][matrix2[0].length]; 
        for(int i = 0; i < matrix1.length; i++) {
            for(int j = 0; j < matrix2[0].length; j++) {
                for(int k = 0; k < matrix1[0].length; k++) {
                    endMatrix[i][j] += matrix1[i][k] * matrix2[k][j];
                }
            }
        }
        return endMatrix;
    }
     
    private void combineMatrices(int index, double[][] matrix) {
        if (index == matrices.size()) {
            totalRotationMatrix = matrix;
        } else {
            double[][] newMatrix = multiplyMatrices(matrix, matrices.get(index));
            combineMatrices(index+1, newMatrix);
        }
     
    }
     
    private void creatematricesFromSeeds(int dimension, double angle) {
        for(int n = 0; n < matrixSeeds.size(); n++) {
            double[][] array = new double[dimension][dimension];
            double[] trigValues = new double[] {Math.cos(angle), -Math.sin(angle), Math.sin(angle), Math.cos(angle)};
            int indexOfTrigValues = 0;
            for(int i = 0; i < dimension; i++) {
                for(int j = 0; j < dimension; j++) {
                    if (i == j && 1 == matrixSeeds.get(n)[j]) {
                        array[i][j] = 1;
                    } else if (1 == matrixSeeds.get(n)[j] || 1 == matrixSeeds.get(n)[i]) {
                        array[i][j] = 0;
                    } else {
                        array[i][j] = trigValues[indexOfTrigValues];
                        indexOfTrigValues += 1;
                    }
                }
            }
            matrices.add(array);
        }
    }
     
    //could have used Boolean[] but 1's and 0's took up less space on the expressions screen
    private void createMatrixSeeds(double[] array) {
        for(int i = 0; i < array.length; i++) {
            if (array[i] != 1 && array.length - sumArray(array) > 2) {
                double[] array2 = array.clone();
                array2[i] = 1;
                if (array2.length - sumArray(array2) == 2) {
                    if (!matrixSeeds.contains(array2)) {
                        matrixSeeds.add(array2);
                    }   
                }
                createMatrixSeeds(array2);
            }
        }
    }
     
     
    //returns the sum of all the values of an array
    private int sumArray(double[] array) {
        int result = 0;
        for (int i = 0; i < array.length; i++) {
            if(array[i] == 1) {
                result += 1;
            }
        }
        return result;
    }
     
    public void realignElements() {
        canvas.setConstants(getWidth()/2, getHeight()/2);
    }
     
    public void stateChanged(ChangeEvent e) {
        JSlider source=(JSlider)e.getSource();
        if (source == rotationSpeed) {
            rotationSpeedValue = (double) (Math.pow(SPEED_BASE, (double) source.getValue()/4)-1)/7000.0;
            rotating = false;
            generatematrices(theDimension, rotationSpeedValue);
            combineMatrices(1, matrices.get(0));
            rotating = true;
        } else if (source == zoom){
            scalarValue = (double) source.getValue();
        }
         
    }
    //buttons top
    JComboBox shapeList, colorList;
     
    //bottom
    JCheckBox bounceBox;
    JCheckBox linesBox;
    JCheckBox circlesBox;
    JButton rotate;
    JSlider rotationSpeed;
    JSlider zoom;
     
     
    //cannot create dimensions above 8 because of memory constraints
    private Boolean bounce = false;
    private double rotationSpeedValue;
    private double scalarValue;
    private int theDimension = 3; 
    private double[][] totalRotationMatrix;
    private ArrayList<double[]> matrixSeeds = new ArrayList<double[]>();
    private ArrayList<double[][]> matrices = new ArrayList<double[][]>();
}
    
